<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ice Slide Penguin — Somnia</title>
  <style>
    /* --- Basic layout --- */
    :root {
      --bg1: #071526;
      --bg2: #00111a;
      --neon: #6ff3ff;
      --card: rgba(10,20,30,0.6);
      --glass-border: rgba(120,200,255,0.08);
    }
    html,body { height:100%; margin:0; font-family:Inter, Roboto, Arial, sans-serif; background: linear-gradient(180deg,var(--bg1),var(--bg2)); color:#e6f7ff; }
    .wrap { display:flex; align-items:center; justify-content:center; height:100vh; padding:20px; box-sizing:border-box; }
    .card { width:420px; max-width:95vw; padding:16px; border-radius:14px; background: linear-gradient(180deg, rgba(8,16,30,0.85), rgba(2,8,12,0.6)); box-shadow: 0 10px 30px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.02); }
    header { display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .title { font-weight:700; font-size:18px; display:flex; gap:10px; align-items:center; }
    .btn { background:transparent; border:1px solid var(--glass-border); padding:8px 10px; border-radius:10px; cursor:pointer; color:var(--neon); font-weight:600; }
    .btn.secondary { color:#fff; border-color: rgba(255,255,255,0.06); }
    #gameCanvas { display:block; margin:0 auto; background: linear-gradient(180deg,#3fb2ff10,#006f9f20); border-radius:8px; width:400px; height:600px; border:1px solid rgba(255,255,255,0.03); }
    .row { display:flex; gap:8px; align-items:center; }
    .hud { display:flex; justify-content:space-between; align-items:center; margin-top:8px; }
    .small { font-size:13px; opacity:0.9; }
    .center { text-align:center; }
    /* Modal */
    .overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(0deg, rgba(0,0,0,0.6), rgba(0,0,0,0.6)); z-index:40; }
    .modal { background:var(--card); padding:18px; border-radius:12px; width:360px; max-width:92vw; border:1px solid rgba(255,255,255,0.03); box-shadow:0 10px 40px rgba(0,0,0,0.7); }
    .leaderboard { margin-top:10px; max-height:240px; overflow:auto; padding:8px; background: rgba(255,255,255,0.02); border-radius:8px; }
    .lb-item { display:flex; justify-content:space-between; padding:6px 8px; border-bottom:1px dashed rgba(255,255,255,0.02); font-size:14px; }
    .muted { color: rgba(255,255,255,0.6); font-size:13px; }
    footer.small { margin-top:10px; text-align:center; opacity:0.8; font-size:12px; }
    .status { font-size:13px; color:#bfefff }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div class="title">❄️ Ice Slide Penguin</div>
        <div>
          <button id="connectBtn" class="btn">Connect Wallet</button>
        </div>
      </header>

      <canvas id="gameCanvas" width="400" height="600"></canvas>

      <div class="hud">
        <div class="small">Score: <span id="scoreDisplay">0</span></div>
        <div class="row">
          <button id="startBtn" class="btn">Start</button>
          <button id="pauseBtn" class="btn secondary">Pause (P)</button>
          <button id="showLeaderboard" class="btn secondary">Leaderboard</button>
        </div>
      </div>

      <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;">
        <div class="muted">Use ← → to move. Collect snowflakes. Avoid ice blocks.</div>
        <div id="walletAddr" class="muted">Not connected</div>
      </div>

      <footer class="small">
        Built for Somnia Christmas Carnival — deploys to Somnia Mainnet. Network must be Somnia.
      </footer>
    </div>
  </div>

  <!-- Modal: Leaderboard & Game Over -->
  <div id="overlay" class="overlay">
    <div class="modal" id="modalContent">
      <div id="modalTitle" style="font-weight:700; font-size:16px;">Leaderboard</div>
      <div id="modalBody" style="margin-top:8px;">
        <div id="leaderboardList" class="leaderboard"></div>

        <div id="gameOverActions" style="display:none; margin-top:10px;">
          <div class="center" style="margin-bottom:8px;">Your score: <strong id="finalScore">0</strong></div>
          <div style="display:flex; gap:8px; justify-content:center;">
            <button id="submitScoreBtn" class="btn">Submit Score (on-chain)</button>
            <button id="retryBtn" class="btn secondary">Retry</button>
          </div>
          <div id="txStatus" class="muted small" style="margin-top:8px;"></div>
        </div>
      </div>
      <div style="display:flex; justify-content:flex-end; margin-top:12px;">
        <button id="closeModal" class="btn secondary">Close</button>
      </div>
    </div>
  </div>

  <!-- Ethers via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.2/dist/ethers.min.js" integrity crossorigin="anonymous"></script>

  <script>
  /********************************************************************
   * CONFIG
   ********************************************************************/
  const CONTRACT_ADDRESS = "0x446387559087C3A2f9766612BEE2626f37D2AD1A";

  // Human-readable ABI entries for ethers
  const CONTRACT_ABI = [
    "function submitScore(uint256) external",
    "function getLeaderboard() external view returns (tuple(address player,uint256 value)[10])",
    "event NewTopScore(address indexed player, uint256 score)"
  ];

  /********************************************************************
   * UI ELEMENTS
   ********************************************************************/
  const connectBtn = document.getElementById("connectBtn");
  const walletAddr = document.getElementById("walletAddr");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const showLeaderboard = document.getElementById("showLeaderboard");
  const overlay = document.getElementById("overlay");
  const closeModal = document.getElementById("closeModal");
  const leaderboardList = document.getElementById("leaderboardList");
  const modalTitle = document.getElementById("modalTitle");
  const gameOverActions = document.getElementById("gameOverActions");
  const finalScoreEl = document.getElementById("finalScore");
  const submitScoreBtn = document.getElementById("submitScoreBtn");
  const retryBtn = document.getElementById("retryBtn");
  const txStatus = document.getElementById("txStatus");
  const scoreDisplay = document.getElementById("scoreDisplay");

  /********************************************************************
   * WEB3 SETUP
   ********************************************************************/
  let provider = null;
  let signer = null;
  let contract = null;
  let userAddress = null;

  async function connectWallet() {
    if (!window.ethereum) {
      alert("MetaMask (or another web3 wallet) is required.");
      return;
    }
    try {
      provider = new ethers.BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      userAddress = await signer.getAddress();
      walletAddr.textContent = userAddress.slice(0,6) + "…" + userAddress.slice(-4);
      connectBtn.textContent = "Connected";
      contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    } catch (err) {
      console.error("connect error", err);
      alert("Wallet connection failed: " + (err && err.message ? err.message : err));
    }
  }

  connectBtn.addEventListener("click", connectWallet);

  /********************************************************************
   * GAME LOGIC (single-file, simple)
   ********************************************************************/
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const W = canvas.width;
  const H = canvas.height;

  // Game states
  const STATE = { MENU: 0, PLAYING: 1, PAUSED: 2, GAMEOVER: 3 };
  let gameState = STATE.MENU;

  // Player
  let penguinX = W/2, penguinY = 500, penguinRadius = 20;
  let leftPressed=false, rightPressed=false;
  let speed = 5;

  // Entities
  let snowflakes = [];
  let obstacles = [];
  let score = 0;
  scoreDisplay.textContent = "0";

  // Timers
  let lastTick = 0;

  // Input
  document.addEventListener("keydown", (e)=>{
    if (e.key === "ArrowLeft") leftPressed = true;
    if (e.key === "ArrowRight") rightPressed = true;
    if (e.key === "p" || e.key === "P") {
      if (gameState === STATE.PLAYING) pauseGame();
      else if (gameState === STATE.PAUSED) resumeGame();
    }
  });
  document.addEventListener("keyup", (e)=>{
    if (e.key === "ArrowLeft") leftPressed = false;
    if (e.key === "ArrowRight") rightPressed = false;
  });

  // Start / Pause buttons
  startBtn.addEventListener("click", ()=> {
    startGame();
  });
  pauseBtn.addEventListener("click", ()=> {
    if (gameState === STATE.PLAYING) pauseGame();
    else if (gameState === STATE.PAUSED) resumeGame();
  });

  // Leaderboard modal
  showLeaderboard.addEventListener("click", async ()=> {
    await openLeaderboard(false);
  });
  closeModal.addEventListener("click", ()=> { overlay.style.display = "none"; });

  retryBtn.addEventListener("click", ()=> {
    overlay.style.display = "none";
    startGame();
  });

  submitScoreBtn.addEventListener("click", async ()=> {
    await submitScoreOnChain();
  });

  // Core functions
  function resetGame() {
    penguinX = W/2;
    snowflakes = [];
    obstacles = [];
    score = 0;
    scoreDisplay.textContent = "0";
  }

  function startGame() {
    resetGame();
    gameState = STATE.PLAYING;
    lastTick = performance.now();
    requestAnimationFrame(loop);
  }

  function pauseGame() {
    if (gameState !== STATE.PLAYING) return;
    gameState = STATE.PAUSED;
    pauseBtn.textContent = "Resume (P)";
  }

  function resumeGame() {
    if (gameState !== STATE.PAUSED) return;
    gameState = STATE.PLAYING;
    pauseBtn.textContent = "Pause (P)";
    lastTick = performance.now();
    requestAnimationFrame(loop);
  }

  function gameOver() {
    gameState = STATE.GAMEOVER;
    // Open modal with leaderboard and submit option
    finalScoreEl.textContent = score;
    modalTitle.textContent = "Game Over";
    gameOverActions.style.display = "block";
    txStatus.textContent = "";
    overlay.style.display = "flex";
    openLeaderboard(true); // show leaderboard together with gameover UI
  }

  // Entity creation
  function spawnSnowflake() {
    const x = Math.random() * (W-10) + 5;
    const size = Math.random() * 6 + 4;
    const spd = Math.random() * 2 + 1;
    snowflakes.push({ x, y: -10, size, spd });
  }

  function spawnObstacle() {
    const width = Math.random() * 60 + 30;
    const x = Math.random() * (W - width);
    const height = 14;
    const spd = 2 + Math.random()*1.4;
    obstacles.push({ x, y: -20, width, height, spd });
  }

  // Collision helpers
  function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
    // find closest point
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < (r*r);
  }

  // Loop
  function update(dt) {
    if (gameState !== STATE.PLAYING) return;

    // Player movement
    if (leftPressed) penguinX -= speed;
    if (rightPressed) penguinX += speed;
    penguinX = Math.max(penguinRadius, Math.min(W - penguinRadius, penguinX));

    // Spawn
    if (Math.random() < 0.035) spawnSnowflake();
    if (Math.random() < 0.012) spawnObstacle();

    // Update snowflakes
    for (let i = snowflakes.length -1; i>=0; i--) {
      const s = snowflakes[i];
      s.y += s.spd;
      // collision with penguin
      const dx = s.x - penguinX;
      const dy = s.y - penguinY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      // check if currently touching an obstacle => steal collect disabled (we keep original logic: if touching obstacle, can't collect)
      let touchingObstacle = obstacles.some(o => circleRectCollision(penguinX, penguinY, penguinRadius, o.x, o.y, o.width, o.height));
      if (dist < s.size + penguinRadius && !touchingObstacle) {
        snowflakes.splice(i,1);
        score++;
        scoreDisplay.textContent = score;
        continue;
      }
      if (s.y > H + 20) snowflakes.splice(i,1);
    }

    // Update obstacles
    for (let i = obstacles.length -1; i>=0; i--) {
      const o = obstacles[i];
      o.y += o.spd;
      // collision with penguin => GAME OVER
      if (circleRectCollision(penguinX, penguinY, penguinRadius, o.x, o.y, o.width, o.height)) {
        gameOver();
        return;
      }
      if (o.y > H + 40) obstacles.splice(i,1);
    }
  }

  function draw() {
    // clear
    ctx.clearRect(0,0,W,H);

    // background decorations
    // subtle grid / snow effect can be added here

    // draw snowflakes
    ctx.fillStyle = "#ffffff";
    for (const s of snowflakes) {
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }

    // draw obstacles
    for (const o of obstacles) {
      ctx.fillStyle = "#00ffff";
      ctx.fillRect(o.x, o.y, o.width, o.height);
      // little highlight
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(o.x+2, o.y+2, Math.min(8,o.width-4), o.height/2);
    }

    // draw penguin (simple)
    // body
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.ellipse(penguinX, penguinY, penguinRadius, penguinRadius+6, 0, 0, Math.PI*2);
    ctx.fill();
    // belly
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.ellipse(penguinX, penguinY+5, penguinRadius*0.6, penguinRadius*0.5, 0, 0, Math.PI*2);
    ctx.fill();
    // eyes (honest look)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(penguinX-6, penguinY-6, 4, 0, Math.PI*2);
    ctx.arc(penguinX+6, penguinY-6, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#000000";
    ctx.beginPath();
    ctx.arc(penguinX-6, penguinY-6, 2, 0, Math.PI*2);
    ctx.arc(penguinX+6, penguinY-6, 2, 0, Math.PI*2);
    ctx.fill();

    // score (also mirrored in DOM)
    // additional UI can be added
  }

  function loop(ts) {
    const dt = ts - lastTick;
    lastTick = ts;
    update(dt);
    draw();
    if (gameState === STATE.PLAYING) requestAnimationFrame(loop);
  }

  // Initially draw a static screen with instructions
  function drawMenu() {
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#ffffff";
    ctx.font = "20px Inter, Arial";
    ctx.textAlign = "center";
    ctx.fillText("Ice Slide Penguin", W/2, 180);
    ctx.font = "14px Inter, Arial";
    ctx.fillText("Collect snowflakes • Avoid ice blocks", W/2, 210);
    ctx.fillText("Use ← → to move • Press Start to play", W/2, 240);
  }
  drawMenu();

  /********************************************************************
   * ON-CHAIN: submit score & read leaderboard
   ********************************************************************/
  async function submitScoreOnChain() {
    if (!contract) {
      await connectWallet();
      if (!contract) return;
    }
    try {
      submitScoreBtn.disabled = true;
      txStatus.textContent = "Requesting signature in wallet...";
      // Call contract.submitScore(uint256)
      const tx = await contract.submitScore(ethers.BigNumber.from(score));
      txStatus.textContent = "Transaction sent — waiting confirmation...";
      await tx.wait();
      txStatus.textContent = "Score submitted! Updating leaderboard...";
      // refresh leaderboard
      await loadLeaderboard();
      txStatus.textContent = "Done.";
    } catch (err) {
      console.error(err);
      txStatus.textContent = "Error: " + (err && err.message ? err.message : err);
    } finally {
      submitScoreBtn.disabled = false;
    }
  }

  async function loadLeaderboard() {
    try {
      // Use read-only provider if wallet not connected
      let readProvider = provider;
      if (!readProvider && window.ethereum) {
        readProvider = new ethers.BrowserProvider(window.ethereum);
      }
      const readContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
      const res = await readContract.getLeaderboard();
      // res is array of tuples: { player, value }
      leaderboardList.innerHTML = "";
      let idx = 1;
      for (const item of res) {
        const addr = item.player;
        const val = item.value ? item.value.toString() : "0";
        if (addr === "0x0000000000000000000000000000000000000000" && val === "0") {
          // skip empty rows but still show placeholders
          leaderboardList.innerHTML += `<div class="lb-item muted">${idx}. —</div>`;
        } else {
          leaderboardList.innerHTML += `<div class="lb-item"><div>${idx}. <span style="font-weight:600; margin-left:6px;">${addr.slice(0,6)}…${addr.slice(-4)}</span></div><div>${val}</div></div>`;
        }
        idx++;
      }
    } catch (err) {
      console.error("loadLeaderboard err", err);
      leaderboardList.innerHTML = `<div class="muted">Failed to load leaderboard: ${err && err.message ? err.message : err}</div>`;
    }
  }

  async function openLeaderboard(isGameOver) {
    modalTitle.textContent = isGameOver ? "Game Over — Leaderboard" : "Leaderboard (Top 10)";
    gameOverActions.style.display = isGameOver ? "block" : "none";
    overlay.style.display = "flex";
    leaderboardList.innerHTML = "<div class='muted'>Loading...</div>";
    await loadLeaderboard();
  }

  // Periodically refresh leaderboard in background
  setInterval(()=> {
    if (overlay.style.display === "flex") loadLeaderboard();
  }, 15_000);

  // Safety: try to auto-connect if already authorized
  (async ()=>{
    if (window.ethereum) {
      try {
        const accounts = await window.ethereum.request({ method: "eth_accounts" });
        if (accounts && accounts.length > 0) {
          await connectWallet();
        }
      } catch(e){}
    }
  })();

  /********************************************************************
   * NOTES FOR YOU
   * - When clicking Submit Score MetaMask will open to confirm tx.
   * - Gas will be paid in SOMI (Somnia). Make sure the connected wallet has funds.
   * - If network is wrong, switch MetaMask to Somnia network.
   ********************************************************************/
  </script>
</body>
</html>
